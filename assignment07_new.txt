Final Implementation:
  - The hardware extracts the kernel arguments, initiates the memory, loads the kernel
    binary, passes the remaining arguments to the kernel and finally switches to the kernel
    (by starting runUntilEception), which handles everything else.
  - The kernel keeps info about itself in a special osTable with one entry. The osTable-
    entry contains exactly the same info as a process table entry, but for the OS.
    The first time the OS switches to a different process the address of this entry is passed
    to the hardware and stored in a special OS-register such that it's always known to the hardware.
  - The initial user process is generated by loading instructions from a binary file.
    Additional processes can only be generated through a fork in the first user process.
  - The kernel manages processes by keeping all relevant info in a process-table.
    Scheduling is done through selecting the next entry in the process table.
  - Syscalls are now called osCalls. If the hardware detects a syscall instuction
    it calls the handleOsCalls-routine, which then saves the current process and loads the
    os-info from the address specified in REG_OS. The OS is then executed and decides what to do
    based on a passed status code (schedule next process or handle oscall).
  - The OS executes the oscall and writes any state changes or return values into the
    process table entry of the calling process and then switches back to the calling process.
  - The kernel's main contains a loop that runs until there are no more
    user processes left to schedule. Then the kernel quits.
  - Preemtive multitasking  is realized through interrupts. When as many instructions as
    specified in TIMESLICE are reached, an interrupt is issued, triggering a switch to the OS
    which then selects the next process by traversing the process table and finding the next
    unfinished process which is then loaded.
  - When all user processes are finished, the kernel quits and issues an exit syscall.
    Normally exit (like all other oscalls) would be handled by the kernel, but if the kernel
    exits there is no kernel left to handle the exit. In this case we instruct the hardware
    to get the exit code from the kernel and throw an EXCEPTION_EXIT.

Results:
  - All Syscalls work.
  - Everything that has to be done by the OS is done by the OS.
  - Tests return the expected results (tested through debug).
  - Debug output was not included due to its size. Letting the kernel copy the
    memory when creating a new process after a fork results in a huge amount of
    instructions since every memory entry of the forking process has to be copied
    to the new process.

Problems:
  - Huge Workload!
  - Passing arguments to kernel -> solved
  - Always accessing valid addresses -> solved
